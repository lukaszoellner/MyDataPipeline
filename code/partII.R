# PREPARATION ================================================================================================
# Install packages if needed
# ----------------
# Part 2
# Drop all existing variables
rm(list = ls())

# Load Libraries
library(RSQLite)
library(DBI)
library(data.table)
library(formattable)
library(ffbase)
library(odbc)
library(httr)
library(ff)
library(knitr)
library(pryr)
library(dplyr)
library(plyr)
library(here)
library(rstudioapi)


# Automatically set working directory with the here() function
setwd(here())
getwd()

# ====================================================================================================================
# Create CSV File

# Create SUBSET CSV FILE
# The main purpose of the read.csv.ffdf function and the ff package is to deal with large data sets.
# Reducing the fec.csv dataset to several MBs withdraws the basic reason to use this package.
# Reading in the entire dataset, still takes more than an hour, though. Since this is a BigData assignment, we
# reduce the data set but keep it at a size which legitimates the purpose of the ff package.
# see SELECTION for which columns are kept

# Count rows of fec.csv, define batch size and calculate number of batches
INPUT_FILE <- "../data/fec.csv"
OUTPUT_FILE <- "../data/fec_Part2.csv"
BATCHSIZE <- 1000000
ROWS <-  length(count.fields(INPUT_FILE))
BATCHES <- round(ROWS/BATCHSIZE)
print(paste0("Number of batches: ", BATCHES))

# Columns we keep in the new csv file
SELECTION <- c("cycle", "transaction_type", "amount", "date", "contributor_type", "contributor_gender",
               "contributor_state", "recipient_party", "recipient_type", "seat", "seat_held",
               "seat_status","seat_result")

# Load batch with headings and write to new CSV file individually before the loop starts
FIRST_BATCH <- fread(INPUT_FILE, nrows = BATCHSIZE, header = TRUE)
column_names <- colnames(FIRST_BATCH)
FIRST_BATCH <- select(FIRST_BATCH, SELECTION)
FIRST_BATCH
count(FIRST_BATCH, "contributor_gender")
fwrite(FIRST_BATCH, file = OUTPUT_FILE, append = FALSE)
rm(FIRST_BATCH)
gc()

# Start of Loop
# Write each Batch in the new CSV file and slice out the columns we will need for further analysis
for (i in 2:BATCHES){
  
  # Calculate rows to be skipped
  skipped = (i-1) * BATCHSIZE + 1
  
  # Extract BATCH with all columns and BATCHSIZE rows
  BATCH <- fread(INPUT_FILE, nrows = BATCHSIZE, header = FALSE, skip = skipped)
  
  # Set column names to know which which columns shall be sliced out
  colnames(BATCH) <- column_names
  
  # Extract the columns as set in SELECTION above
  BATCH <- select(BATCH, SELECTION)
  
  # Write to new CSV file (Path = OUTPUT_FILE)
  fwrite(BATCH, file = OUTPUT_FILE, append = TRUE)
  print(paste0("Batch written: ", (i-1)))
  
  #Delete current batch and clean RAM
  rm(BATCH)
  gc()
}

print ("fec.part_2.csv was generated")


# =====================================================================================================================
# Create ffdf object

# The new csv file has a size of approx. 1.55GB which is considerably less than the orginal one which has approx. 8GB.
# In the following we will not use all variables. We just kept them to demonstrate the applicability of the ff package
# and its virtual memory application.
#Set working directory for data junks generated by the read.csv.ffdf function
options(fftempdir = getwd())

# Read the csv file with the key variable information into R using ffdf. Data junk will be saved in code folder.
# We will read in several columns which we will drop in our further analysis again. This would not be very smart
# in an actual analysis. However, we want to present the basic idea of the read.csv.ffdf function.
alpha <- read.csv.ffdf(file = OUTPUT_FILE, VERBOSE = TRUE, header = TRUE, next.rows = 1500000, colClasses = NA)

# Object size of freshly generated object
object.size(alpha)

# We created several batches stored in the code folder. We have thus shown the rationale of the read.csv.ffdf function and its virtual memory.
# idea. It becomes more and more necessary the more data we have to deal with. In the following part we will drop the columns we won't need for
# our further analysis.

# Drop columns
beta <- subset(alpha, select=c("cycle", "amount", "contributor_type", "contributor_gender", "recipient_party",
                               "recipient_type", "seat", "seat_held", "seat_status", "seat_result"))

# Investigate the data levels in each of the category below, apart from numeric/vastly many values such as cycle and amount and date
levels(beta$contributor_type)
levels(beta$contributor_gender)
levels(beta$recipient_party)
levels(beta$recipient_type)
levels(beta$seat)
levels(beta$seat_held)
levels(beta$seat_status)
levels(beta$seat_result)
levels(beta$seat_cycle)
levels(beta$amount)


# Analysis
# Plot


#selection of the data plot
gammaplot_ffdf<- subset.ffdf(beta, select =c("cycle", "seat", "seat_status"), seat_status=="I")
gammaplot_df <- as.data.frame(gammaplot_ffdf)
gammaplot_df[,'seat'] <- gsub(":","",gammaplot_df$seat)
gammaplot_subdf <- gammaplot_df[gammaplot_df$seat=="federalhouse",]


countseat <- count(gammaplot_subdf, vars="cycle")

#create a nicely formatted plot showing the number of incumbent seats for the house of representatives per year

p<- ggplot(gammaplot_subdf,aes(x = cycle, y=seat)) + geom_point()
p <- p +theme(plot.margin = margin(1,1,1,1,"cm"),
              plot.title = element_text(hjust = 0.5),
              panel.grid.minor = element_blank(), 
              panel.grid.major = element_line(color = "gray60", size = 0.5),
              panel.grid.major.x = element_blank(),
              panel.background = element_blank())
p<-p+ ylab("Number of Incumbent Seats")+xlab("Year") + ggtitle("Evolution of Incumbent House of Representative Seats")
p


#selection of data regression
#subsetting the data and transformation to dataframe

gammareg_ffdf <- subset.ffdf(beta, select = c("amount","seat_status", "seat_result", "seat"), (seat_result=="W"|seat_result=="L"))
gammareg_df <- as.data.frame(gammareg_ffdf)
gammareg_df$seat_inc_dummy = ifelse(gammareg_df$seat_status== "I",1 , 0)
gammareg_df$win = ifelse(gammareg_df$seat_result== "W",1 , 0)
gammareg_df[,'seat'] <- gsub(":","",gammareg_df$seat)
gammareg_subdf <- subset(gammareg_df, seat=="federalhouse")
colnames(gammareg_subdf) <- c("amount", "seat_status", "seat_result", "seat", "win", "inc_dummy")

#run a logistic regression on seat being incumbent on winning an election
mm<-glm(win ~ inc_dummy , data=gammareg_subdf, family=binomial(link="logit"), control=list(maxit=50))
sumfortab<- summary(mm)
reporttable<-as.data.frame(sumfortab$coefficients)

#create nicely formatted table for the markdown of the coefficient from the logistic regression
kable(reporttable, format="markdown", big.mark=",")
